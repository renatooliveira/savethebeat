use crate::config::Config;
use crate::error::AppError;
use base64::{Engine, engine::general_purpose::URL_SAFE_NO_PAD};
use chrono::{DateTime, Duration, Utc};
use oauth2::{AuthUrl, ClientId, ClientSecret, RedirectUrl, TokenUrl, basic::BasicClient};
use rand::Rng;
use std::collections::HashMap;
use std::sync::{Arc, RwLock};

/// OAuth state store for CSRF protection
pub type StateStore = Arc<RwLock<HashMap<String, OAuthState>>>;

/// OAuth state metadata
#[derive(Debug, Clone)]
pub struct OAuthState {
    pub slack_workspace_id: String,
    pub slack_user_id: String,
    pub created_at: DateTime<Utc>,
}

impl OAuthState {
    /// Check if the state token has expired (older than 10 minutes)
    pub fn is_expired(&self) -> bool {
        let now = Utc::now();
        let expiry = self.created_at + Duration::minutes(10);
        now >= expiry
    }
}

/// Build OAuth2 client for Spotify
///
/// # Arguments
/// * `config` - Application configuration with Spotify credentials
///
/// # Returns
/// Configured BasicClient for Spotify OAuth flow
pub fn build_oauth_client(config: &Config) -> BasicClient {
    let client_id = ClientId::new(config.spotify_client_id.clone());
    let client_secret = ClientSecret::new(config.spotify_client_secret.clone());
    let auth_url = AuthUrl::new("https://accounts.spotify.com/authorize".to_string())
        .expect("Invalid auth URL");
    let token_url = TokenUrl::new("https://accounts.spotify.com/api/token".to_string())
        .expect("Invalid token URL");
    let redirect_url =
        RedirectUrl::new(config.spotify_redirect_uri.clone()).expect("Invalid redirect URL");

    BasicClient::new(client_id, Some(client_secret), auth_url, Some(token_url))
        .set_redirect_uri(redirect_url)
}

/// Generate a cryptographically secure random state token
///
/// # Returns
/// Base64-encoded URL-safe random token (32 bytes)
pub fn generate_state_token() -> String {
    let mut rng = rand::thread_rng();
    let random_bytes: [u8; 32] = rng.r#gen();
    URL_SAFE_NO_PAD.encode(random_bytes)
}

/// Store OAuth state with metadata
///
/// # Arguments
/// * `store` - State store
/// * `token` - State token (generated by generate_state_token)
/// * `workspace_id` - Slack workspace ID
/// * `user_id` - Slack user ID
pub fn store_state(store: &StateStore, token: String, workspace_id: String, user_id: String) {
    let state = OAuthState {
        slack_workspace_id: workspace_id.clone(),
        slack_user_id: user_id.clone(),
        created_at: Utc::now(),
    };

    let mut map = store
        .write()
        .expect("Failed to acquire write lock on state store");
    map.insert(token, state);

    tracing::debug!(
        "Stored OAuth state for workspace={}, user={}",
        workspace_id,
        user_id
    );
}

/// Validate and consume OAuth state token
///
/// Validates that the state token exists, hasn't expired, and removes it from the store.
/// This implements one-time use tokens for CSRF protection.
///
/// # Arguments
/// * `store` - State store
/// * `token` - State token to validate
///
/// # Returns
/// Tuple of (workspace_id, user_id) if valid
///
/// # Errors
/// Returns error if:
/// - State token not found
/// - State token has expired (> 10 minutes old)
pub fn validate_and_consume_state(
    store: &StateStore,
    token: &str,
) -> Result<(String, String), AppError> {
    let mut map = store
        .write()
        .expect("Failed to acquire write lock on state store");

    // Remove the state (one-time use)
    let state = map.remove(token).ok_or(AppError::OAuthStateNotFound)?;

    // Check if expired
    if state.is_expired() {
        tracing::warn!("OAuth state expired for token");
        return Err(AppError::OAuthStateExpired);
    }

    tracing::info!(
        "Validated OAuth state for workspace={}, user={}",
        state.slack_workspace_id,
        state.slack_user_id
    );

    Ok((state.slack_workspace_id, state.slack_user_id))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_state_token() {
        let token1 = generate_state_token();
        let token2 = generate_state_token();

        // Tokens should be non-empty
        assert!(!token1.is_empty());
        assert!(!token2.is_empty());

        // Tokens should be unique
        assert_ne!(token1, token2);

        // Tokens should be base64 URL-safe (no padding)
        assert!(!token1.contains('='));
        assert!(!token2.contains('='));
    }

    #[test]
    fn test_store_and_validate_state() {
        let store = Arc::new(RwLock::new(HashMap::new()));
        let token = generate_state_token();

        // Store state
        store_state(
            &store,
            token.clone(),
            "T123".to_string(),
            "U456".to_string(),
        );

        // Validate and consume
        let result = validate_and_consume_state(&store, &token);
        assert!(result.is_ok());

        let (workspace_id, user_id) = result.unwrap();
        assert_eq!(workspace_id, "T123");
        assert_eq!(user_id, "U456");

        // Token should be consumed (removed from store)
        let result2 = validate_and_consume_state(&store, &token);
        assert!(result2.is_err());
        assert!(matches!(result2.unwrap_err(), AppError::OAuthStateNotFound));
    }

    #[test]
    fn test_validate_state_not_found() {
        let store = Arc::new(RwLock::new(HashMap::new()));
        let result = validate_and_consume_state(&store, "nonexistent_token");

        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), AppError::OAuthStateNotFound));
    }

    #[test]
    fn test_oauth_state_expiry() {
        let now = Utc::now();

        // Fresh state - not expired
        let fresh_state = OAuthState {
            slack_workspace_id: "T123".to_string(),
            slack_user_id: "U456".to_string(),
            created_at: now,
        };
        assert!(!fresh_state.is_expired());

        // Old state - expired (11 minutes ago)
        let old_state = OAuthState {
            slack_workspace_id: "T123".to_string(),
            slack_user_id: "U456".to_string(),
            created_at: now - Duration::minutes(11),
        };
        assert!(old_state.is_expired());

        // Edge case - exactly 10 minutes (should be expired)
        let edge_state = OAuthState {
            slack_workspace_id: "T123".to_string(),
            slack_user_id: "U456".to_string(),
            created_at: now - Duration::minutes(10),
        };
        assert!(edge_state.is_expired());
    }

    #[test]
    fn test_validate_expired_state() {
        let store = Arc::new(RwLock::new(HashMap::new()));
        let token = generate_state_token();

        // Create an expired state
        let expired_state = OAuthState {
            slack_workspace_id: "T123".to_string(),
            slack_user_id: "U456".to_string(),
            created_at: Utc::now() - Duration::minutes(11),
        };

        // Manually insert expired state
        {
            let mut map = store.write().unwrap();
            map.insert(token.clone(), expired_state);
        }

        // Validate should fail with expired error
        let result = validate_and_consume_state(&store, &token);
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), AppError::OAuthStateExpired));
    }

    #[test]
    fn test_build_oauth_client() {
        let config = Config {
            port: 3000,
            host: "0.0.0.0".to_string(),
            database_url: "postgresql://localhost/test".to_string(),
            spotify_client_id: "test_client_id".to_string(),
            spotify_client_secret: "test_client_secret".to_string(),
            spotify_redirect_uri: "http://localhost:3000/spotify/callback".to_string(),
            base_url: "http://localhost:3000".to_string(),
            slack_signing_secret: None,
            slack_bot_token: None,
            rust_log: "info".to_string(),
        };

        let client = build_oauth_client(&config);

        // Client should be successfully created (we can't inspect internals easily,
        // but if it doesn't panic, it's good)
        assert!(std::mem::size_of_val(&client) > 0);
    }
}
